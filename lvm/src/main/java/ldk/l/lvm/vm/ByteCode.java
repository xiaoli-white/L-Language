package ldk.l.lvm.vm;

public class ByteCode {
    private ByteCode() {
    }

    public static final byte LITTLE_ENDIAN = 0;
    public static final byte BIG_ENDIAN = 1;
    public static final long REGISTER_COUNT = 42;
    public static final byte RETURN_VALUE_REGISTER = 36;
    public static final byte BP_REGISTER = 37;
    public static final byte SP_REGISTER = 38;
    public static final byte PC_REGISTER = 39;
    public static final byte FLAGS_REGISTER = 40;
    public static final byte IDTR_REGISTER = 41;
    public static final long ZERO_MARK = 1;
    public static final long CARRY_MARK = 1 << 1;
    public static final long UNSIGNED_MARK = 1 << 2;
    public static final long PAGE_NOT_READABLE = 1 << 3;
    public static final long PAGE_NOT_WRITABLE = 1 << 4;
    public static final long PAGE_NOT_EXECUTABLE = 1 << 5;
    public static final byte BYTE_TYPE = 0;
    public static final byte SHORT_TYPE = 1;
    public static final byte INT_TYPE = 2;
    public static final byte LONG_TYPE = 3;
    public static final byte FLOAT_TYPE = 4;
    public static final byte DOUBLE_TYPE = 5;
    public static final byte TC_STOP = 0; // TC = Thread Control
    public static final byte TC_WAIT = 1;
    public static final byte TC_GET_REGISTER = 2;
    public static final byte TC_SET_REGISTER = 3;
    public static final byte INTERRUPT_DIVIDE_BY_ZERO = 0;
    public static final byte INTERRUPT_PAGE_ERROR = 1;

    public static final byte NOP = 0x00;
    public static final byte PUSH_1 = 0x01;
    public static final byte PUSH_2 = 0x02;
    public static final byte PUSH_4 = 0x03;
    public static final byte PUSH_8 = 0x04;
    public static final byte POP_1 = 0x05;
    public static final byte POP_2 = 0x06;
    public static final byte POP_4 = 0x07;
    public static final byte POP_8 = 0x08;
    public static final byte LOAD_1 = 0x09;
    public static final byte LOAD_2 = 0x0a;
    public static final byte LOAD_4 = 0x0b;
    public static final byte LOAD_8 = 0x0c;
    public static final byte STORE_1 = 0x0d;
    public static final byte STORE_2 = 0x0e;
    public static final byte STORE_4 = 0x0f;
    public static final byte STORE_8 = 0x10;
    public static final byte CMP = 0x11;
    public static final byte ATOMIC_CMP = 0x12;
    public static final byte MOV_E = 0x13;
    public static final byte MOV_NE = 0x14;
    public static final byte MOV_L = 0x15;
    public static final byte MOV_LE = 0x16;
    public static final byte MOV_G = 0x17;
    public static final byte MOV_GE = 0x18;
    public static final byte MOV_UL = 0x19;
    public static final byte MOV_ULE = 0x1a;
    public static final byte MOV_UG = 0x1b;
    public static final byte MOV_UGE = 0x1c;
    public static final byte MOV = 0x1d;
    public static final byte MOV_IMMEDIATE1 = 0x1e;
    public static final byte MOV_IMMEDIATE2 = 0x1f;
    public static final byte MOV_IMMEDIATE4 = 0x20;
    public static final byte MOV_IMMEDIATE8 = 0x21;
    public static final byte JUMP = 0x22;
    public static final byte JUMP_IMMEDIATE = 0x23;
    public static final byte JE = 0x24;
    public static final byte JNE = 0x25;
    public static final byte JL = 0x26;
    public static final byte JLE = 0x27;
    public static final byte JG = 0x28;
    public static final byte JGE = 0x29;
    public static final byte JUL = 0x2a;
    public static final byte JULE = 0x2b;
    public static final byte JUG = 0x2c;
    public static final byte JUGE = 0x2d;
    public static final byte MALLOC = 0x2e;
    public static final byte FREE = 0x2f;
    public static final byte REALLOC = 0x30;
    public static final byte ADD = 0x31;
    public static final byte SUB = 0x32;
    public static final byte MUL = 0x33;
    public static final byte DIV = 0x34;
    public static final byte MOD = 0x35;
    public static final byte AND = 0x36;
    public static final byte OR = 0x37;
    public static final byte XOR = 0x38;
    public static final byte NOT = 0x39;
    public static final byte NEG = 0x3a;
    public static final byte SHL = 0x3b;
    public static final byte SHR = 0x3c;
    public static final byte USHR = 0x3d;
    public static final byte INC = 0x3e;
    public static final byte DEC = 0x3f;
    public static final byte ADD_DOUBLE = 0x40;
    public static final byte SUB_DOUBLE = 0x41;
    public static final byte MUL_DOUBLE = 0x42;
    public static final byte DIV_DOUBLE = 0x43;
    public static final byte MOD_DOUBLE = 0x44;
    public static final byte ADD_FLOAT = 0x45;
    public static final byte SUB_FLOAT = 0x46;
    public static final byte MUL_FLOAT = 0x47;
    public static final byte DIV_FLOAT = 0x48;
    public static final byte MOD_FLOAT = 0x49;
    public static final byte ATOMIC_ADD = 0x4a;
    public static final byte ATOMIC_SUB = 0x4b;
    public static final byte ATOMIC_MUL = 0x4c;
    public static final byte ATOMIC_DIV = 0x4d;
    public static final byte ATOMIC_MOD = 0x4e;
    public static final byte ATOMIC_AND = 0x4f;
    public static final byte ATOMIC_OR = 0x50;
    public static final byte ATOMIC_XOR = 0x51;
    public static final byte ATOMIC_NOT = 0x52;
    public static final byte ATOMIC_NEG = 0x53;
    public static final byte ATOMIC_SHL = 0x54;
    public static final byte ATOMIC_SHR = 0x55;
    public static final byte ATOMIC_USHR = 0x56;
    public static final byte ATOMIC_INC = 0x57;
    public static final byte ATOMIC_DEC = 0x58;
    public static final byte ATOMIC_ADD_DOUBLE = 0x59;
    public static final byte ATOMIC_SUB_DOUBLE = 0x5a;
    public static final byte ATOMIC_MUL_DOUBLE = 0x5b;
    public static final byte ATOMIC_DIV_DOUBLE = 0x5c;
    public static final byte ATOMIC_MOD_DOUBLE = 0x5d;
    public static final byte ATOMIC_ADD_FLOAT = 0x5e;
    public static final byte ATOMIC_SUB_FLOAT = 0x5f;
    public static final byte ATOMIC_MUL_FLOAT = 0x60;
    public static final byte ATOMIC_DIV_FLOAT = 0x61;
    public static final byte ATOMIC_MOD_FLOAT = 0x62;
    public static final byte CAS = 0x63;
    public static final byte INVOKE = 0x64;
    public static final byte INVOKE_IMMEDIATE = 0x65;
    public static final byte RETURN = 0x66;
    public static final byte INTERRUPT = 0x67;
    public static final byte INTERRUPT_RETURN = 0x68;
    public static final byte INT_TYPE_CAST = 0x69;
    public static final byte LONG_TO_DOUBLE = 0x6a;
    public static final byte DOUBLE_TO_LONG = 0x6b;
    public static final byte DOUBLE_TO_FLOAT = 0x6c;
    public static final byte FLOAT_TO_DOUBLE = 0x6d;
    public static final byte OPEN = 0x6e;
    public static final byte CLOSE = 0x6f;
    public static final byte READ = 0x70;
    public static final byte WRITE = 0x71;
    public static final byte CREATE_FRAME = 0x72;
    public static final byte DESTROY_FRAME = 0x73;
    public static final byte EXIT = 0x74;
    public static final byte EXIT_IMMEDIATE = 0x75;
    public static final byte GET_FIELD_ADDRESS = 0x76;
    public static final byte GET_LOCAL_ADDRESS = 0x77;
    public static final byte GET_PARAMETER_ADDRESS = 0x78;
    public static final byte CREATE_THREAD = 0x79;
    public static final byte THREAD_CONTROL = 0x7a;
    public static final byte LOAD_FIELD = 0x7b;
    public static final byte STORE_FIELD = 0x7c;
    public static final byte LOAD_LOCAL = 0x7d;
    public static final byte STORE_LOCAL = 0x7e;
    public static final byte LOAD_PARAMETER = 0x7f;
    public static final byte STORE_PARAMETER = (byte) 0x80;
    public static final byte JUMP_IF_TRUE = (byte) 0x81;
    public static final byte JUMP_IF_FALSE = (byte) 0x82;
    public static final byte SYSCALL = (byte) 0x83;
    public static final byte THREAD_FINISH = (byte) 0x84;
    public static final byte NEG_DOUBLE = (byte) 0x85;
    public static final byte NEG_FLOAT = (byte) 0x86;
    public static final byte ATOMIC_NEG_DOUBLE = (byte) 0x87;
    public static final byte ATOMIC_NEG_FLOAT = (byte) 0x88;
    public static final byte JIT_FOR_RANGE = (byte) 0x89;
    public static final byte INVOKE_NATIVE = (byte) 0x8a;

    public static String getInstructionName(byte code) {
        return switch (code) {
            case NOP -> "NOP";
            case PUSH_1 -> "PUSH_1";
            case PUSH_2 -> "PUSH_2";
            case PUSH_4 -> "PUSH_4";
            case PUSH_8 -> "PUSH_8";
            case POP_1 -> "POP_1";
            case POP_2 -> "POP_2";
            case POP_4 -> "POP_4";
            case POP_8 -> "POP_8";
            case LOAD_1 -> "LOAD_1";
            case LOAD_2 -> "LOAD_2";
            case LOAD_4 -> "LOAD_4";
            case LOAD_8 -> "LOAD_8";
            case STORE_1 -> "STORE_1";
            case STORE_2 -> "STORE_2";
            case STORE_4 -> "STORE_4";
            case STORE_8 -> "STORE_8";
            case CMP -> "CMP";
            case ATOMIC_CMP -> "ATOMIC_CMP";
            case MOV_E -> "MOV_E";
            case MOV_NE -> "MOV_NE";
            case MOV_L -> "MOV_L";
            case MOV_LE -> "MOV_LE";
            case MOV_G -> "MOV_G";
            case MOV_GE -> "MOV_GE";
            case MOV_UL -> "MOV_UL";
            case MOV_ULE -> "MOV_ULE";
            case MOV_UG -> "MOV_UG";
            case MOV_UGE -> "MOV_UGE";
            case MOV -> "MOV";
            case MOV_IMMEDIATE1 -> "MOV_IMMEDIATE1";
            case MOV_IMMEDIATE2 -> "MOV_IMMEDIATE2";
            case MOV_IMMEDIATE4 -> "MOV_IMMEDIATE4";
            case MOV_IMMEDIATE8 -> "MOV_IMMEDIATE8";
            case JUMP -> "JUMP";
            case JUMP_IMMEDIATE -> "JUMP_IMMEDIATE";
            case JE -> "JE";
            case JNE -> "JNE";
            case JL -> "JL";
            case JLE -> "JLE";
            case JG -> "JG";
            case JGE -> "JGE";
            case JUL -> "JUL";
            case JULE -> "JULE";
            case JUG -> "JUG";
            case JUGE -> "JUGE";
            case MALLOC -> "MALLOC";
            case FREE -> "FREE";
            case REALLOC -> "REALLOC";
            case ADD -> "ADD";
            case SUB -> "SUB";
            case MUL -> "MUL";
            case DIV -> "DIV";
            case MOD -> "MOD";
            case AND -> "AND";
            case OR -> "OR";
            case XOR -> "XOR";
            case NOT -> "NOT";
            case NEG -> "NEG";
            case SHL -> "SHL";
            case SHR -> "SHR";
            case USHR -> "USHR";
            case INC -> "INC";
            case DEC -> "DEC";
            case ADD_DOUBLE -> "ADD_DOUBLE";
            case SUB_DOUBLE -> "SUB_DOUBLE";
            case MUL_DOUBLE -> "MUL_DOUBLE";
            case DIV_DOUBLE -> "DIV_DOUBLE";
            case MOD_DOUBLE -> "MOD_DOUBLE";
            case ADD_FLOAT -> "ADD_FLOAT";
            case SUB_FLOAT -> "SUB_FLOAT";
            case MUL_FLOAT -> "MUL_FLOAT";
            case DIV_FLOAT -> "DIV_FLOAT";
            case MOD_FLOAT -> "MOD_FLOAT";
            case ATOMIC_ADD -> "ATOMIC_ADD";
            case ATOMIC_SUB -> "ATOMIC_SUB";
            case ATOMIC_MUL -> "ATOMIC_MUL";
            case ATOMIC_DIV -> "ATOMIC_DIV";
            case ATOMIC_MOD -> "ATOMIC_MOD";
            case ATOMIC_AND -> "ATOMIC_AND";
            case ATOMIC_OR -> "ATOMIC_OR";
            case ATOMIC_XOR -> "ATOMIC_XOR";
            case ATOMIC_NOT -> "ATOMIC_NOT";
            case ATOMIC_NEG -> "ATOMIC_NEG";
            case ATOMIC_SHL -> "ATOMIC_SHL";
            case ATOMIC_SHR -> "ATOMIC_SHR";
            case ATOMIC_USHR -> "ATOMIC_USHR";
            case ATOMIC_INC -> "ATOMIC_INC";
            case ATOMIC_DEC -> "ATOMIC_DEC";
            case ATOMIC_ADD_DOUBLE -> "ATOMIC_ADD_DOUBLE";
            case ATOMIC_SUB_DOUBLE -> "ATOMIC_SUB_DOUBLE";
            case ATOMIC_MUL_DOUBLE -> "ATOMIC_MUL_DOUBLE";
            case ATOMIC_DIV_DOUBLE -> "ATOMIC_DIV_DOUBLE";
            case ATOMIC_MOD_DOUBLE -> "ATOMIC_MOD_DOUBLE";
            case ATOMIC_ADD_FLOAT -> "ATOMIC_ADD_FLOAT";
            case ATOMIC_SUB_FLOAT -> "ATOMIC_SUB_FLOAT";
            case ATOMIC_MUL_FLOAT -> "ATOMIC_MUL_FLOAT";
            case ATOMIC_DIV_FLOAT -> "ATOMIC_DIV_FLOAT";
            case ATOMIC_MOD_FLOAT -> "ATOMIC_MOD_FLOAT";
            case CAS -> "CAS";
            case INVOKE -> "INVOKE";
            case INVOKE_IMMEDIATE -> "INVOKE_IMMEDIATE";
            case RETURN -> "RETURN";
            case INTERRUPT -> "INTERRUPT";
            case INTERRUPT_RETURN -> "INTERRUPT_RETURN";
            case INT_TYPE_CAST -> "INT_TYPE_CAST";
            case LONG_TO_DOUBLE -> "LONG_TO_DOUBLE";
            case DOUBLE_TO_LONG -> "DOUBLE_TO_LONG";
            case DOUBLE_TO_FLOAT -> "DOUBLE_TO_FLOAT";
            case FLOAT_TO_DOUBLE -> "FLOAT_TO_DOUBLE";
            case OPEN -> "OPEN";
            case CLOSE -> "CLOSE";
            case READ -> "READ";
            case WRITE -> "WRITE";
            case CREATE_FRAME -> "CREATE_FRAME";
            case DESTROY_FRAME -> "DESTROY_FRAME";
            case EXIT -> "EXIT";
            case EXIT_IMMEDIATE -> "EXIT_IMMEDIATE";
            case GET_FIELD_ADDRESS -> "GET_FIELD_ADDRESS";
            case GET_LOCAL_ADDRESS -> "GET_LOCAL_ADDRESS";
            case GET_PARAMETER_ADDRESS -> "GET_PARAMETER_ADDRESS";
            case CREATE_THREAD -> "CREATE_THREAD";
            case THREAD_CONTROL -> "THREAD_CONTROL";
            case LOAD_FIELD -> "LOAD_FIELD";
            case STORE_FIELD -> "STORE_FIELD";
            case LOAD_LOCAL -> "LOAD_LOCAL";
            case STORE_LOCAL -> "STORE_LOCAL";
            case LOAD_PARAMETER -> "LOAD_PARAMETER";
            case STORE_PARAMETER -> "STORE_PARAMETER";
            case JUMP_IF_TRUE -> "JUMP_IF_TRUE";
            case JUMP_IF_FALSE -> "JUMP_IF_FALSE";
            case SYSCALL -> "SYSCALL";
            case THREAD_FINISH -> "THREAD_FINISH";
            case NEG_DOUBLE -> "NEG_DOUBLE";
            case NEG_FLOAT -> "NEG_FLOAT";
            case ATOMIC_NEG_DOUBLE -> "ATOMIC_NEG_DOUBLE";
            case ATOMIC_NEG_FLOAT -> "ATOMIC_NEG_FLOAT";
            case JIT_FOR_RANGE -> "JIT_FOR_RANGE";
            case INVOKE_NATIVE -> "INVOKE_NATIVE";
            default -> throw new IllegalArgumentException("Unknown instruction code: " + code);
        };
    }

    public static byte parseInstructionCode(String code) {
        return switch (code.toUpperCase()) {
            case "NOP" -> NOP;
            case "PUSH_1" -> PUSH_1;
            case "PUSH_2" -> PUSH_2;
            case "PUSH_4" -> PUSH_4;
            case "PUSH_8" -> PUSH_8;
            case "POP_1" -> POP_1;
            case "POP_2" -> POP_2;
            case "POP_4" -> POP_4;
            case "POP_8" -> POP_8;
            case "LOAD_1" -> LOAD_1;
            case "LOAD_2" -> LOAD_2;
            case "LOAD_4" -> LOAD_4;
            case "LOAD_8" -> LOAD_8;
            case "STORE_1" -> STORE_1;
            case "STORE_2" -> STORE_2;
            case "STORE_4" -> STORE_4;
            case "STORE_8" -> STORE_8;
            case "CMP" -> CMP;
            case "ATOMIC_CMP" -> ATOMIC_CMP;
            case "MOV_E" -> MOV_E;
            case "MOV_NE" -> MOV_NE;
            case "MOV_L" -> MOV_L;
            case "MOV_LE" -> MOV_LE;
            case "MOV_G" -> MOV_G;
            case "MOV_GE" -> MOV_GE;
            case "MOV_UL" -> MOV_UL;
            case "MOV_ULE" -> MOV_ULE;
            case "MOV_UG" -> MOV_UG;
            case "MOV_UGE" -> MOV_UGE;
            case "MOV" -> MOV;
            case "MOV_IMMEDIATE1" -> MOV_IMMEDIATE1;
            case "MOV_IMMEDIATE2" -> MOV_IMMEDIATE2;
            case "MOV_IMMEDIATE4" -> MOV_IMMEDIATE4;
            case "MOV_IMMEDIATE8" -> MOV_IMMEDIATE8;
            case "JUMP" -> JUMP;
            case "JUMP_IMMEDIATE" -> JUMP_IMMEDIATE;
            case "JE" -> JE;
            case "JNE" -> JNE;
            case "JL" -> JL;
            case "JLE" -> JLE;
            case "JG" -> JG;
            case "JGE" -> JGE;
            case "JUL" -> JUL;
            case "JULE" -> JULE;
            case "JUG" -> JUG;
            case "JUGE" -> JUGE;
            case "MALLOC" -> MALLOC;
            case "FREE" -> FREE;
            case "REALLOC" -> REALLOC;
            case "ADD" -> ADD;
            case "SUB" -> SUB;
            case "MUL" -> MUL;
            case "DIV" -> DIV;
            case "MOD" -> MOD;
            case "AND" -> AND;
            case "OR" -> OR;
            case "XOR" -> XOR;
            case "NOT" -> NOT;
            case "NEG" -> NEG;
            case "SHL" -> SHL;
            case "SHR" -> SHR;
            case "USHR" -> USHR;
            case "INC" -> INC;
            case "DEC" -> DEC;
            case "ADD_DOUBLE" -> ADD_DOUBLE;
            case "SUB_DOUBLE" -> SUB_DOUBLE;
            case "MUL_DOUBLE" -> MUL_DOUBLE;
            case "DIV_DOUBLE" -> DIV_DOUBLE;
            case "MOD_DOUBLE" -> MOD_DOUBLE;
            case "ADD_FLOAT" -> ADD_FLOAT;
            case "SUB_FLOAT" -> SUB_FLOAT;
            case "MUL_FLOAT" -> MUL_FLOAT;
            case "DIV_FLOAT" -> DIV_FLOAT;
            case "MOD_FLOAT" -> MOD_FLOAT;
            case "ATOMIC_ADD" -> ATOMIC_ADD;
            case "ATOMIC_SUB" -> ATOMIC_SUB;
            case "ATOMIC_MUL" -> ATOMIC_MUL;
            case "ATOMIC_DIV" -> ATOMIC_DIV;
            case "ATOMIC_MOD" -> ATOMIC_MOD;
            case "ATOMIC_AND" -> ATOMIC_AND;
            case "ATOMIC_OR" -> ATOMIC_OR;
            case "ATOMIC_XOR" -> ATOMIC_XOR;
            case "ATOMIC_NOT" -> ATOMIC_NOT;
            case "ATOMIC_NEG" -> ATOMIC_NEG;
            case "ATOMIC_SHL" -> ATOMIC_SHL;
            case "ATOMIC_SHR" -> ATOMIC_SHR;
            case "ATOMIC_USHR" -> ATOMIC_USHR;
            case "ATOMIC_INC" -> ATOMIC_INC;
            case "ATOMIC_DEC" -> ATOMIC_DEC;
            case "ATOMIC_ADD_DOUBLE" -> ATOMIC_ADD_DOUBLE;
            case "ATOMIC_SUB_DOUBLE" -> ATOMIC_SUB_DOUBLE;
            case "ATOMIC_MUL_DOUBLE" -> ATOMIC_MUL_DOUBLE;
            case "ATOMIC_DIV_DOUBLE" -> ATOMIC_DIV_DOUBLE;
            case "ATOMIC_MOD_DOUBLE" -> ATOMIC_MOD_DOUBLE;
            case "ATOMIC_ADD_FLOAT" -> ATOMIC_ADD_FLOAT;
            case "ATOMIC_SUB_FLOAT" -> ATOMIC_SUB_FLOAT;
            case "ATOMIC_MUL_FLOAT" -> ATOMIC_MUL_FLOAT;
            case "ATOMIC_DIV_FLOAT" -> ATOMIC_DIV_FLOAT;
            case "ATOMIC_MOD_FLOAT" -> ATOMIC_MOD_FLOAT;
            case "CAS" -> CAS;
            case "INVOKE" -> INVOKE;
            case "INVOKE_IMMEDIATE" -> INVOKE_IMMEDIATE;
            case "RETURN" -> RETURN;
            case "INTERRUPT" -> INTERRUPT;
            case "INTERRUPT_RETURN" -> INTERRUPT_RETURN;
            case "INT_TYPE_CAST" -> INT_TYPE_CAST;
            case "LONG_TO_DOUBLE" -> LONG_TO_DOUBLE;
            case "DOUBLE_TO_LONG" -> DOUBLE_TO_LONG;
            case "DOUBLE_TO_FLOAT" -> DOUBLE_TO_FLOAT;
            case "FLOAT_TO_DOUBLE" -> FLOAT_TO_DOUBLE;
            case "OPEN" -> OPEN;
            case "CLOSE" -> CLOSE;
            case "READ" -> READ;
            case "WRITE" -> WRITE;
            case "CREATE_FRAME" -> CREATE_FRAME;
            case "DESTROY_FRAME" -> DESTROY_FRAME;
            case "EXIT" -> EXIT;
            case "EXIT_IMMEDIATE" -> EXIT_IMMEDIATE;
            case "GET_FIELD_ADDRESS" -> GET_FIELD_ADDRESS;
            case "GET_LOCAL_ADDRESS" -> GET_LOCAL_ADDRESS;
            case "GET_PARAMETER_ADDRESS" -> GET_PARAMETER_ADDRESS;
            case "CREATE_THREAD" -> CREATE_THREAD;
            case "THREAD_CONTROL" -> THREAD_CONTROL;
            case "LOAD_FIELD" -> LOAD_FIELD;
            case "STORE_FIELD" -> STORE_FIELD;
            case "LOAD_LOCAL" -> LOAD_LOCAL;
            case "STORE_LOCAL" -> STORE_LOCAL;
            case "LOAD_PARAMETER" -> LOAD_PARAMETER;
            case "STORE_PARAMETER" -> STORE_PARAMETER;
            case "JUMP_IF_TRUE" -> JUMP_IF_TRUE;
            case "JUMP_IF_FALSE" -> JUMP_IF_FALSE;
            case "SYSCALL" -> SYSCALL;
            case "THREAD_FINISH" -> THREAD_FINISH;
            case "NEG_DOUBLE" -> NEG_DOUBLE;
            case "NEG_FLOAT" -> NEG_FLOAT;
            case "ATOMIC_NEG_DOUBLE" -> ATOMIC_NEG_DOUBLE;
            case "ATOMIC_NEG_FLOAT" -> ATOMIC_NEG_FLOAT;
            case "JIT_FOR_RANGE" -> JIT_FOR_RANGE;
            case "INVOKE_NATIVE" -> INVOKE_NATIVE;
            default -> throw new IllegalArgumentException("Unknown instruction code: " + code);
        };
    }

    public static boolean isJump(byte code) {
        int i = code & 0xFF;
        return (i >= JUMP && i <= JUGE) || i == (JUMP_IF_TRUE & 0xFF) || i == (JUMP_IF_FALSE & 0xFF);
    }

    public static boolean isConditionalJump(byte code) {
        int i = code & 0xFF;
        return (i >= JE && i <= JUGE) || i == (JUMP_IF_TRUE & 0xFF) || i == (JUMP_IF_FALSE & 0xFF);
    }

    public static boolean isUnconditionalJump(byte code) {
        int i = code & 0xFF;
        return i == JUMP || i == JUMP_IMMEDIATE;
    }

    public static boolean isArithmetic(byte code) {
        int i = code & 0xFF;
        return i >= ADD && i <= DEC;
    }
}
